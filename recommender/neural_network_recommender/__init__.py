import itertools
import logging
from typing import List, Union

import pandas
import common
from recommender import get_reviewer_data, get_comment_data, get_members_of_repo, RecommenderImplementation, \
    RecommenderImplementationBase

class MLPClassifierImplementationBase(RecommenderImplementationBase):
    """
    A base class for the class that is used to train the neural network recommender
    and also the class that uses the trained models to produce recommendations. Allows
    access to common methods.
    """
    @staticmethod
    def preprocess_into_pandas_data_frame(repository: str) -> dict[str, pandas.DataFrame]:
        """
        Process the repo-specific data into a pandas DataFrame to be used for either training
        or making recommendations.

        :param repository: The repository this DataFrame should be generated for.
        :return: The pandas DataFrame.
        """
        return_data = {}
        # Collate the code review vote percentages data into a DataFrame.
        reviewer_data = get_reviewer_data()[repository]
        for key in common.TimePeriods:
            key = key.value
            return_data[key] = pandas.DataFrame.from_dict(reviewer_data[key]).transpose()
            return_data[key].rename(index={x: x.strip() for x in return_data[key].index.array})
            for username in common.username_exclude_list:
                username = common.convert_name_to_index_format(username)
                if username in return_data[key].index:
                    return_data[key].drop(username)

        index_form_to_data_frame_username = {
            key.value: {common.convert_name_to_index_format(name): name for name in return_data[key.value].index} for key in common.TimePeriods
        }

        # Add the comment percentages data to the DataFrame.
        comment_data = get_comment_data()[repository]
        for key in common.TimePeriods:
            key = key.value
            return_data[key]["Comments"] = 0
            for username, comment_count in comment_data[key].items():
                if common.convert_name_to_index_format(username) in common.username_exclude_list:
                    continue
                index_form_username = common.convert_name_to_index_format(username)
                if index_form_username in index_form_to_data_frame_username[key].keys():
                    username = index_form_to_data_frame_username[key][index_form_username]
                else:
                    # Username doesn't exist. Add it.
                    (return_data[key]).loc[username] = 0
                    # Add it to the index
                    index_form_to_data_frame_username[key][index_form_username] = username
                (return_data[key]).at[username.strip(), "Comments"] = comment_count
        # Add a column for each user to indicate whether they can merge changes on the repository.
        users_with_rights_to_merge = get_members_of_repo(repository)
        logging.debug("users with right to merge: " + str(users_with_rights_to_merge))
        for key, data_frame in return_data.items():
            data_frame: pandas.DataFrame
            data_frame["Can merge changes?"] = False
            for user in users_with_rights_to_merge:
                def mark_as_can_merge_changes(key_for_user: str):
                    if key_for_user in user:
                        username_index_form = common.convert_name_to_index_format(user[key_for_user])
                        if username_index_form in index_form_to_data_frame_username[key].keys():
                            username = index_form_to_data_frame_username[key][username_index_form]
                            data_frame.at[username, "Can merge changes?"] = True
                            return True
                    return False
                for key_for_name in ['name', 'display_name', 'username']:
                    if mark_as_can_merge_changes(key_for_name):
                        break
                else:
                    username = user['name']
                    # Add the user with the right to merge to the data frame.
                    (return_data[key]).loc[username] = 0
                    data_frame.at[username, "Can merge changes?"] = True
                    # Add it to the index
                    index_form_to_data_frame_username[key][common.convert_name_to_index_format(username)] = username
        return return_data

    @classmethod
    def add_change_specific_attributes_to_data_frame(cls, repository: str, change_info: dict, data_frame: pandas.DataFrame) -> pandas.DataFrame:
        """
        Add change specific attributes, which in this case is the git blame data, to the DataFrame generated by
        ::preprocess_into_pandas_data_frame.

        :param repository: The repository the DataFrame and change are for
        :param change_info: The change info associated with the change
        :param data_frame: The DataFrame generated by ::preprocess_into_pandas_data_frame for the
         repository in the repository argument.
        """
        # Make a copy as this will modify the DataFrame and cause the master repo-specific copy to be modified too.
        data_frame = data_frame.copy(True)
        time_period_to_key = {y.value: y.value.replace(' ', '_') + "_lines_count" for y in common.TimePeriods}
        index_form_to_data_frame_username = {
            common.convert_name_to_index_format(name): name for name in data_frame.index
        }
        git_blame_info = cls.get_change_git_blame_info(repository, change_info)
        # Add columns for the author and reviewer git blame percentages
        for name in itertools.chain.from_iterable([
            [y.value + x for y in common.TimePeriods] for x in
            [" author git blame percentage", " reviewer git blame percentage"]
        ]):
            data_frame[name] = 0
        def is_a_name_used_in_data_frame(names: Union[List[str], str]):
            """
            Helper function that returns a Truthy value if
            the name is already used in the DataFrame otherwise
            returns False.

            :param names: The username(s) that are being checked.
            """
            if isinstance(names, str):
                names = [names]
            for name in names:
                # De-duplicate by using index format to find similar usernames that
                #  are almost certainly the same person.
                name_index_form = common.convert_name_to_index_format(name)
                if name_index_form in index_form_to_data_frame_username.keys():
                    return index_form_to_data_frame_username[name_index_form]
            return False
        # Process the author git blame percentages
        for time_period, column in {y.value: y.value + " author git blame percentage" for y in
                                    common.TimePeriods}.items():
            for author_email, percentage in git_blame_info["authors"][time_period_to_key[time_period]].items():
                if author_email in git_blame_info["names"] and len(git_blame_info["names"][author_email]):
                    data_frame_name = is_a_name_used_in_data_frame(git_blame_info["names"][author_email])
                    if not data_frame_name:
                        # If the data frame doesn't have any of the names, then use the first name
                        data_frame_name = git_blame_info["names"][author_email][0]
                else:
                    # Shouldn't occur, but use email if no name was given for the commit.
                    data_frame_name = author_email
                if data_frame_name not in data_frame.index.values:
                    data_frame.loc[data_frame_name, :] = 0
                data_frame.at[data_frame_name, column] = percentage
        # Process the reviewer git blame percentages
        for time_period, column in {y.value: y.value + " reviewer git blame percentage" for y in
                                    common.TimePeriods}.items():
            for committer_email, percentage in git_blame_info["committers"][time_period_to_key[time_period]].items():
                if committer_email in git_blame_info["names"] and len(git_blame_info["names"][committer_email]):
                    data_frame_name = is_a_name_used_in_data_frame(git_blame_info["names"][committer_email])
                    if not data_frame_name:
                        # If the data frame doesn't have any of the names, then use the first name
                        data_frame_name = git_blame_info["names"][committer_email][0]
                else:
                    # Shouldn't occur, but use email if no name was given for the commit.
                    data_frame_name = committer_email
                if data_frame_name not in data_frame.index.values:
                    data_frame.loc[data_frame_name, :] = 0
                data_frame.at[data_frame_name, column] = percentage
        return data_frame